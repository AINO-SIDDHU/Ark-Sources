"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const cloud_assembly_1 = require("../../lib/api/cxapp/cloud-assembly");
const context_providers_1 = require("../../lib/context-providers");
const util_1 = require("../util");
describe('AWS::CDK::Metadata', () => {
    test('is generated for relocatable stacks', async () => {
        var _a;
        const cx = await testCloudExecutable({ env: `aws://${cxapi.UNKNOWN_ACCOUNT}/${cxapi.UNKNOWN_REGION}`, versionReporting: true });
        const cxasm = await cx.synthesize();
        const result = cxasm.stackById('withouterrors').firstStack;
        const metadata = result.template.Resources && result.template.Resources.CDKMetadata;
        expect(metadata).toEqual({
            Type: 'AWS::CDK::Metadata',
            Properties: {
                // eslint-disable-next-line @typescript-eslint/no-require-imports
                Modules: `${require('../../package.json').name}=${require('../../package.json').version}`
            },
            Condition: 'CDKMetadataAvailable',
        });
        expect((_a = result.template.Conditions) === null || _a === void 0 ? void 0 : _a.CDKMetadataAvailable).toBeDefined();
    });
    test('is generated for stacks in supported regions', async () => {
        const cx = await testCloudExecutable({ env: 'aws://012345678912/us-east-1', versionReporting: true });
        const cxasm = await cx.synthesize();
        const result = cxasm.stackById('withouterrors').firstStack;
        const metadata = result.template.Resources && result.template.Resources.CDKMetadata;
        expect(metadata).toEqual({
            Type: 'AWS::CDK::Metadata',
            Properties: {
                // eslint-disable-next-line @typescript-eslint/no-require-imports
                Modules: `${require('../../package.json').name}=${require('../../package.json').version}`
            }
        });
    });
    test('is not generated for stacks in unsupported regions', async () => {
        const cx = await testCloudExecutable({ env: 'aws://012345678912/bermuda-triangle-1337', versionReporting: true });
        const cxasm = await cx.synthesize();
        const result = cxasm.stackById('withouterrors').firstStack;
        const metadata = result.template.Resources && result.template.Resources.CDKMetadata;
        expect(metadata).toBeUndefined();
    });
});
test('stop executing if context providers are not making progress', async () => {
    context_providers_1.registerContextProvider('testprovider', class {
        async getValue(_) {
            return 'foo';
        }
    });
    const cloudExecutable = new util_1.MockCloudExecutable({
        stacks: [{
                stackName: 'thestack',
                template: { resource: 'noerrorresource' },
            }],
        // Always return the same missing keys, synthesis should still finish.
        missing: [
            { key: 'abcdef', props: {}, provider: 'testprovider' }
        ]
    });
    const cxasm = await cloudExecutable.synthesize();
    // WHEN
    await cxasm.selectStacks(['thestack'], { defaultBehavior: cloud_assembly_1.DefaultSelection.AllStacks });
    // THEN: the test finishes normally});
});
async function testCloudExecutable({ env, versionReporting = true } = {}) {
    const cloudExec = new util_1.MockCloudExecutable({
        stacks: [{
                stackName: 'withouterrors',
                env,
                template: { resource: 'noerrorresource' },
            },
            {
                stackName: 'witherrors',
                env,
                template: { resource: 'errorresource' },
                metadata: {
                    '/resource': [
                        {
                            type: cxapi.ERROR_METADATA_KEY,
                            data: 'this is an error'
                        }
                    ]
                },
            }]
    });
    cloudExec.configuration.settings.set(['versionReporting'], versionReporting);
    return cloudExec;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWQtZXhlY3V0YWJsZS50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY2xvdWQtZXhlY3V0YWJsZS50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQXlDO0FBQ3pDLHVFQUFzRTtBQUN0RSxtRUFBc0U7QUFDdEUsa0NBQThDO0FBRTlDLFFBQVEsQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUU7SUFDbEMsSUFBSSxDQUFDLHFDQUFxQyxFQUFFLEtBQUssSUFBSSxFQUFFOztRQUNyRCxNQUFNLEVBQUUsR0FBRyxNQUFNLG1CQUFtQixDQUFDLEVBQUUsR0FBRyxFQUFFLFNBQVMsS0FBSyxDQUFDLGVBQWUsSUFBSSxLQUFLLENBQUMsY0FBYyxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUNoSSxNQUFNLEtBQUssR0FBRyxNQUFNLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUVwQyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxDQUFDLFVBQVUsQ0FBQztRQUMzRCxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUM7UUFDcEYsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQztZQUN2QixJQUFJLEVBQUUsb0JBQW9CO1lBQzFCLFVBQVUsRUFBRTtnQkFDVixpRUFBaUU7Z0JBQ2pFLE9BQU8sRUFBRSxHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxPQUFPLEVBQUU7YUFDMUY7WUFDRCxTQUFTLEVBQUUsc0JBQXNCO1NBQ2xDLENBQUMsQ0FBQztRQUVILE1BQU0sT0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVUsMENBQUUsb0JBQW9CLENBQUMsQ0FBQyxX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O2dCQUNILFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRTthQUMxQztZQUNEO2dCQUNFLFNBQVMsRUFBRSxZQUFZO2dCQUN2QixHQUFHO2dCQUNILFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxlQUFlLEVBQUU7Z0JBQ3ZDLFFBQVEsRUFBRTtvQkFDUixXQUFXLEVBQUU7d0JBQ1g7NEJBQ0UsSUFBSSxFQUFFLEtBQUssQ0FBQyxrQkFBa0I7NEJBQzlCLElBQUksRUFBRSxrQkFBa0I7eUJBQ3pCO3FCQUNGO2lCQUNGO2FBQ0YsQ0FBQztLQUNILENBQUMsQ0FBQztJQUNILFNBQVMsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUU3RSxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IERlZmF1bHRTZWxlY3Rpb24gfSBmcm9tICcuLi8uLi9saWIvYXBpL2N4YXBwL2Nsb3VkLWFzc2VtYmx5JztcbmltcG9ydCB7IHJlZ2lzdGVyQ29udGV4dFByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vbGliL2NvbnRleHQtcHJvdmlkZXJzJztcbmltcG9ydCB7IE1vY2tDbG91ZEV4ZWN1dGFibGUgfSBmcm9tICcuLi91dGlsJztcblxuZGVzY3JpYmUoJ0FXUzo6Q0RLOjpNZXRhZGF0YScsICgpID0+IHtcbiAgdGVzdCgnaXMgZ2VuZXJhdGVkIGZvciByZWxvY2F0YWJsZSBzdGFja3MnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY3ggPSBhd2FpdCB0ZXN0Q2xvdWRFeGVjdXRhYmxlKHsgZW52OiBgYXdzOi8vJHtjeGFwaS5VTktOT1dOX0FDQ09VTlR9LyR7Y3hhcGkuVU5LTk9XTl9SRUdJT059YCwgdmVyc2lvblJlcG9ydGluZzogdHJ1ZSB9KTtcbiAgICBjb25zdCBjeGFzbSA9IGF3YWl0IGN4LnN5bnRoZXNpemUoKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGN4YXNtLnN0YWNrQnlJZCgnd2l0aG91dGVycm9ycycpLmZpcnN0U3RhY2s7XG4gICAgY29uc3QgbWV0YWRhdGEgPSByZXN1bHQudGVtcGxhdGUuUmVzb3VyY2VzICYmIHJlc3VsdC50ZW1wbGF0ZS5SZXNvdXJjZXMuQ0RLTWV0YWRhdGE7XG4gICAgZXhwZWN0KG1ldGFkYXRhKS50b0VxdWFsKHtcbiAgICAgIFR5cGU6ICdBV1M6OkNESzo6TWV0YWRhdGEnLFxuICAgICAgUHJvcGVydGllczoge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICBNb2R1bGVzOiBgJHtyZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS5uYW1lfT0ke3JlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb259YFxuICAgICAgfSxcbiAgICAgIENvbmRpdGlvbjogJ0NES01ldGFkYXRhQXZhaWxhYmxlJyxcbiAgICB9KTtcblxuICAgIGV4cGVjdChyZXN1bHQudGVtcGxhdGUuQ29uZGl0aW9ucz8uQ0RLTWV0YWRhdGFBdmFpbGFibGUpLnRvQmVEZWZpbmVkKCk7XG4gIH0pO1xuXG4gIHRlc3QoJ2lzIGdlbmVyYXRlZCBmb3Igc3RhY2tzIGluIHN1cHBvcnRlZCByZWdpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGN4ID0gYXdhaXQgdGVzdENsb3VkRXhlY3V0YWJsZSh7IGVudjogJ2F3czovLzAxMjM0NTY3ODkxMi91cy1lYXN0LTEnLCB2ZXJzaW9uUmVwb3J0aW5nOiB0cnVlIH0pO1xuICAgIGNvbnN0IGN4YXNtID0gYXdhaXQgY3guc3ludGhlc2l6ZSgpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gY3hhc20uc3RhY2tCeUlkKCd3aXRob3V0ZXJyb3JzJykuZmlyc3RTdGFjaztcbiAgICBjb25zdCBtZXRhZGF0YSA9IHJlc3VsdC50ZW1wbGF0ZS5SZXNvdXJjZXMgJiYgcmVzdWx0LnRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YTtcbiAgICBleHBlY3QobWV0YWRhdGEpLnRvRXF1YWwoe1xuICAgICAgVHlwZTogJ0FXUzo6Q0RLOjpNZXRhZGF0YScsXG4gICAgICBQcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gICAgICAgIE1vZHVsZXM6IGAke3JlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLm5hbWV9PSR7cmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbn1gXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHRlc3QoJ2lzIG5vdCBnZW5lcmF0ZWQgZm9yIHN0YWNrcyBpbiB1bnN1cHBvcnRlZCByZWdpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGN4ID0gYXdhaXQgdGVzdENsb3VkRXhlY3V0YWJsZSh7IGVudjogJ2F3czovLzAxMjM0NTY3ODkxMi9iZXJtdWRhLXRyaWFuZ2xlLTEzMzcnLCB2ZXJzaW9uUmVwb3J0aW5nOiB0cnVlIH0pO1xuICAgIGNvbnN0IGN4YXNtID0gYXdhaXQgY3guc3ludGhlc2l6ZSgpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gY3hhc20uc3RhY2tCeUlkKCd3aXRob3V0ZXJyb3JzJykuZmlyc3RTdGFjaztcbiAgICBjb25zdCBtZXRhZGF0YSA9IHJlc3VsdC50ZW1wbGF0ZS5SZXNvdXJjZXMgJiYgcmVzdWx0LnRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YTtcbiAgICBleHBlY3QobWV0YWRhdGEpLnRvQmVVbmRlZmluZWQoKTtcbiAgfSk7XG59KTtcblxudGVzdCgnc3RvcCBleGVjdXRpbmcgaWYgY29udGV4dCBwcm92aWRlcnMgYXJlIG5vdCBtYWtpbmcgcHJvZ3Jlc3MnLCBhc3luYyAoKSA9PiB7XG4gIHJlZ2lzdGVyQ29udGV4dFByb3ZpZGVyKCd0ZXN0cHJvdmlkZXInLCBjbGFzcyB7XG4gICAgcHVibGljIGFzeW5jIGdldFZhbHVlKF86IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiBQcm9taXNlPGFueT4ge1xuICAgICAgcmV0dXJuICdmb28nO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgY2xvdWRFeGVjdXRhYmxlID0gbmV3IE1vY2tDbG91ZEV4ZWN1dGFibGUoe1xuICAgIHN0YWNrczogW3tcbiAgICAgIHN0YWNrTmFtZTogJ3RoZXN0YWNrJyxcbiAgICAgIHRlbXBsYXRlOiB7IHJlc291cmNlOiAnbm9lcnJvcnJlc291cmNlJyB9LFxuICAgIH1dLFxuICAgIC8vIEFsd2F5cyByZXR1cm4gdGhlIHNhbWUgbWlzc2luZyBrZXlzLCBzeW50aGVzaXMgc2hvdWxkIHN0aWxsIGZpbmlzaC5cbiAgICBtaXNzaW5nOiBbXG4gICAgICB7IGtleTogJ2FiY2RlZicsIHByb3BzOiB7fSwgcHJvdmlkZXI6ICd0ZXN0cHJvdmlkZXInIH1cbiAgICBdXG4gIH0pO1xuICBjb25zdCBjeGFzbSA9IGF3YWl0IGNsb3VkRXhlY3V0YWJsZS5zeW50aGVzaXplKCk7XG5cbiAgLy8gV0hFTlxuICBhd2FpdCBjeGFzbS5zZWxlY3RTdGFja3MoWyd0aGVzdGFjayddLCB7IGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbi5BbGxTdGFja3MgfSk7XG5cbiAgLy8gVEhFTjogdGhlIHRlc3QgZmluaXNoZXMgbm9ybWFsbHl9KTtcbn0pO1xuXG5hc3luYyBmdW5jdGlvbiB0ZXN0Q2xvdWRFeGVjdXRhYmxlKHsgZW52LCB2ZXJzaW9uUmVwb3J0aW5nID0gdHJ1ZSB9OiB7IGVudj86IHN0cmluZywgdmVyc2lvblJlcG9ydGluZz86IGJvb2xlYW4gfSA9IHt9KSB7XG4gIGNvbnN0IGNsb3VkRXhlYyA9IG5ldyBNb2NrQ2xvdWRFeGVjdXRhYmxlKHtcbiAgICBzdGFja3M6IFt7XG4gICAgICBzdGFja05hbWU6ICd3aXRob3V0ZXJyb3JzJyxcbiAgICAgIGVudixcbiAgICAgIHRlbXBsYXRlOiB7IHJlc291cmNlOiAnbm9lcnJvcnJlc291cmNlJyB9LFxuICAgIH0sXG4gICAge1xuICAgICAgc3RhY2tOYW1lOiAnd2l0aGVycm9ycycsXG4gICAgICBlbnYsXG4gICAgICB0ZW1wbGF0ZTogeyByZXNvdXJjZTogJ2Vycm9ycmVzb3VyY2UnIH0sXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICAnL3Jlc291cmNlJzogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IGN4YXBpLkVSUk9SX01FVEFEQVRBX0tFWSxcbiAgICAgICAgICAgIGRhdGE6ICd0aGlzIGlzIGFuIGVycm9yJ1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICB9XVxuICB9KTtcbiAgY2xvdWRFeGVjLmNvbmZpZ3VyYXRpb24uc2V0dGluZ3Muc2V0KFsndmVyc2lvblJlcG9ydGluZyddLCB2ZXJzaW9uUmVwb3J0aW5nKTtcblxuICByZXR1cm4gY2xvdWRFeGVjO1xufVxuIl19