"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs");
const path = require("path");
const cloud_executable_1 = require("../lib/api/cxapp/cloud-executable");
const settings_1 = require("../lib/settings");
const mock_sdk_1 = require("./util/mock-sdk");
class MockCloudExecutable extends cloud_executable_1.CloudExecutable {
    constructor(assembly) {
        const configuration = new settings_1.Configuration();
        const sdkProvider = new mock_sdk_1.MockSdkProvider();
        super({
            configuration,
            sdkProvider,
            synthesizer: () => Promise.resolve(testAssembly(assembly))
        });
        this.configuration = configuration;
        this.sdkProvider = sdkProvider;
    }
}
exports.MockCloudExecutable = MockCloudExecutable;
function testAssembly(assembly) {
    const builder = new cxapi.CloudAssemblyBuilder();
    for (const stack of assembly.stacks) {
        const templateFile = `${stack.stackName}.template.json`;
        fs.writeFileSync(path.join(builder.outdir, templateFile), JSON.stringify(stack.template, undefined, 2));
        const metadata = { ...stack.metadata };
        for (const asset of stack.assets || []) {
            metadata[asset.id] = [
                { type: cxapi.ASSET_METADATA, data: asset }
            ];
        }
        for (const missing of assembly.missing || []) {
            builder.addMissing(missing);
        }
        builder.addArtifact(stack.stackName, {
            type: cxapi.ArtifactType.AWS_CLOUDFORMATION_STACK,
            environment: stack.env || 'aws://12345/here',
            dependencies: stack.depends,
            metadata,
            properties: {
                templateFile
            }
        });
    }
    return builder.buildAssembly();
}
function testStack(stack) {
    const assembly = testAssembly({ stacks: [stack] });
    return assembly.getStackByName(stack.stackName);
}
exports.testStack = testStack;
/**
 * Return a mocked instance of a class, given its constructor
 *
 * I don't understand why jest doesn't provide this by default,
 * but there you go.
 *
 * FIXME: Currently very limited. Doesn't support inheritance, getters or
 * automatic detection of properties (as those exist on instances, not
 * classes).
 */
function classMockOf(ctr) {
    const ret = {};
    for (const methodName of Object.getOwnPropertyNames(ctr.prototype)) {
        ret[methodName] = jest.fn();
    }
    return ret;
}
exports.classMockOf = classMockOf;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5Q0FBeUM7QUFDekMseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3Qix3RUFBb0U7QUFDcEUsOENBQWdEO0FBQ2hELDhDQUFrRDtBQWdCbEQsTUFBYSxtQkFBb0IsU0FBUSxrQ0FBZTtJQUl0RCxZQUFZLFFBQXNCO1FBQ2hDLE1BQU0sYUFBYSxHQUFHLElBQUksd0JBQWEsRUFBRSxDQUFDO1FBQzFDLE1BQU0sV0FBVyxHQUFHLElBQUksMEJBQWUsRUFBRSxDQUFDO1FBRTFDLEtBQUssQ0FBQztZQUNKLGFBQWE7WUFDYixXQUFXO1lBQ1gsV0FBVyxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzNELENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO1FBQ25DLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ2pDLENBQUM7Q0FDRjtBQWpCRCxrREFpQkM7QUFFRCxTQUFTLFlBQVksQ0FBQyxRQUFzQjtJQUMxQyxNQUFNLE9BQU8sR0FBRyxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO0lBRWpELEtBQUssTUFBTSxLQUFLLElBQUksUUFBUSxDQUFDLE1BQU0sRUFBRTtRQUNuQyxNQUFNLFlBQVksR0FBRyxHQUFHLEtBQUssQ0FBQyxTQUFTLGdCQUFnQixDQUFDO1FBQ3hELEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV4RyxNQUFNLFFBQVEsR0FBOEMsRUFBRSxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNsRixLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksRUFBRSxFQUFFO1lBQ3RDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUc7Z0JBQ25CLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxjQUFjLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRTthQUM1QyxDQUFDO1NBQ0g7UUFFRCxLQUFLLE1BQU0sT0FBTyxJQUFJLFFBQVEsQ0FBQyxPQUFPLElBQUksRUFBRSxFQUFFO1lBQzVDLE9BQU8sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDN0I7UUFFRCxPQUFPLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUU7WUFDbkMsSUFBSSxFQUFFLEtBQUssQ0FBQyxZQUFZLENBQUMsd0JBQXdCO1lBQ2pELFdBQVcsRUFBRSxLQUFLLENBQUMsR0FBRyxJQUFJLGtCQUFrQjtZQUU1QyxZQUFZLEVBQUUsS0FBSyxDQUFDLE9BQU87WUFDM0IsUUFBUTtZQUNSLFVBQVUsRUFBRTtnQkFDVixZQUFZO2FBQ2I7U0FDRixDQUFDLENBQUM7S0FDSjtJQUVELE9BQU8sT0FBTyxDQUFDLGFBQWEsRUFBRSxDQUFDO0FBQ2pDLENBQUM7QUFFRCxTQUFnQixTQUFTLENBQUMsS0FBd0I7SUFDaEQsTUFBTSxRQUFRLEdBQUcsWUFBWSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ25ELE9BQU8sUUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDbEQsQ0FBQztBQUhELDhCQUdDO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsU0FBZ0IsV0FBVyxDQUFJLEdBQThCO0lBQzNELE1BQU0sR0FBRyxHQUFRLEVBQUUsQ0FBQztJQUNwQixLQUFLLE1BQU0sVUFBVSxJQUFJLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUU7UUFDbEUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztLQUM3QjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQU5ELGtDQU1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBDbG91ZEV4ZWN1dGFibGUgfSBmcm9tICcuLi9saWIvYXBpL2N4YXBwL2Nsb3VkLWV4ZWN1dGFibGUnO1xuaW1wb3J0IHsgQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uL2xpYi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBNb2NrU2RrUHJvdmlkZXIgfSBmcm9tICcuL3V0aWwvbW9jay1zZGsnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RTdGFja0FydGlmYWN0IHtcbiAgc3RhY2tOYW1lOiBzdHJpbmc7XG4gIHRlbXBsYXRlOiBhbnk7XG4gIGVudj86IHN0cmluZyxcbiAgZGVwZW5kcz86IHN0cmluZ1tdO1xuICBtZXRhZGF0YT86IGN4YXBpLlN0YWNrTWV0YWRhdGE7XG4gIGFzc2V0cz86IGN4YXBpLkFzc2V0TWV0YWRhdGFFbnRyeVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RBc3NlbWJseSB7XG4gIHN0YWNrczogVGVzdFN0YWNrQXJ0aWZhY3RbXTtcbiAgbWlzc2luZz86IGN4YXBpLk1pc3NpbmdDb250ZXh0W107XG59XG5cbmV4cG9ydCBjbGFzcyBNb2NrQ2xvdWRFeGVjdXRhYmxlIGV4dGVuZHMgQ2xvdWRFeGVjdXRhYmxlIHtcbiAgcHVibGljIHJlYWRvbmx5IGNvbmZpZ3VyYXRpb246IENvbmZpZ3VyYXRpb247XG4gIHB1YmxpYyByZWFkb25seSBzZGtQcm92aWRlcjogTW9ja1Nka1Byb3ZpZGVyO1xuXG4gIGNvbnN0cnVjdG9yKGFzc2VtYmx5OiBUZXN0QXNzZW1ibHkpIHtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gbmV3IENvbmZpZ3VyYXRpb24oKTtcbiAgICBjb25zdCBzZGtQcm92aWRlciA9IG5ldyBNb2NrU2RrUHJvdmlkZXIoKTtcblxuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgICBzZGtQcm92aWRlcixcbiAgICAgIHN5bnRoZXNpemVyOiAoKSA9PiBQcm9taXNlLnJlc29sdmUodGVzdEFzc2VtYmx5KGFzc2VtYmx5KSlcbiAgICB9KTtcblxuICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5zZGtQcm92aWRlciA9IHNka1Byb3ZpZGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RBc3NlbWJseShhc3NlbWJseTogVGVzdEFzc2VtYmx5KTogY3hhcGkuQ2xvdWRBc3NlbWJseSB7XG4gIGNvbnN0IGJ1aWxkZXIgPSBuZXcgY3hhcGkuQ2xvdWRBc3NlbWJseUJ1aWxkZXIoKTtcblxuICBmb3IgKGNvbnN0IHN0YWNrIG9mIGFzc2VtYmx5LnN0YWNrcykge1xuICAgIGNvbnN0IHRlbXBsYXRlRmlsZSA9IGAke3N0YWNrLnN0YWNrTmFtZX0udGVtcGxhdGUuanNvbmA7XG4gICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oYnVpbGRlci5vdXRkaXIsIHRlbXBsYXRlRmlsZSksIEpTT04uc3RyaW5naWZ5KHN0YWNrLnRlbXBsYXRlLCB1bmRlZmluZWQsIDIpKTtcblxuICAgIGNvbnN0IG1ldGFkYXRhOiB7IFtwYXRoOiBzdHJpbmddOiBjeGFwaS5NZXRhZGF0YUVudHJ5W10gfSA9IHsgLi4uc3RhY2subWV0YWRhdGEgfTtcbiAgICBmb3IgKGNvbnN0IGFzc2V0IG9mIHN0YWNrLmFzc2V0cyB8fCBbXSkge1xuICAgICAgbWV0YWRhdGFbYXNzZXQuaWRdID0gW1xuICAgICAgICB7IHR5cGU6IGN4YXBpLkFTU0VUX01FVEFEQVRBLCBkYXRhOiBhc3NldCB9XG4gICAgICBdO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgbWlzc2luZyBvZiBhc3NlbWJseS5taXNzaW5nIHx8IFtdKSB7XG4gICAgICBidWlsZGVyLmFkZE1pc3NpbmcobWlzc2luZyk7XG4gICAgfVxuXG4gICAgYnVpbGRlci5hZGRBcnRpZmFjdChzdGFjay5zdGFja05hbWUsIHtcbiAgICAgIHR5cGU6IGN4YXBpLkFydGlmYWN0VHlwZS5BV1NfQ0xPVURGT1JNQVRJT05fU1RBQ0ssXG4gICAgICBlbnZpcm9ubWVudDogc3RhY2suZW52IHx8ICdhd3M6Ly8xMjM0NS9oZXJlJyxcblxuICAgICAgZGVwZW5kZW5jaWVzOiBzdGFjay5kZXBlbmRzLFxuICAgICAgbWV0YWRhdGEsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHRlbXBsYXRlRmlsZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkZXIuYnVpbGRBc3NlbWJseSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVzdFN0YWNrKHN0YWNrOiBUZXN0U3RhY2tBcnRpZmFjdCkge1xuICBjb25zdCBhc3NlbWJseSA9IHRlc3RBc3NlbWJseSh7IHN0YWNrczogW3N0YWNrXSB9KTtcbiAgcmV0dXJuIGFzc2VtYmx5LmdldFN0YWNrQnlOYW1lKHN0YWNrLnN0YWNrTmFtZSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbW9ja2VkIGluc3RhbmNlIG9mIGEgY2xhc3MsIGdpdmVuIGl0cyBjb25zdHJ1Y3RvclxuICpcbiAqIEkgZG9uJ3QgdW5kZXJzdGFuZCB3aHkgamVzdCBkb2Vzbid0IHByb3ZpZGUgdGhpcyBieSBkZWZhdWx0LFxuICogYnV0IHRoZXJlIHlvdSBnby5cbiAqXG4gKiBGSVhNRTogQ3VycmVudGx5IHZlcnkgbGltaXRlZC4gRG9lc24ndCBzdXBwb3J0IGluaGVyaXRhbmNlLCBnZXR0ZXJzIG9yXG4gKiBhdXRvbWF0aWMgZGV0ZWN0aW9uIG9mIHByb3BlcnRpZXMgKGFzIHRob3NlIGV4aXN0IG9uIGluc3RhbmNlcywgbm90XG4gKiBjbGFzc2VzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzTW9ja09mPEE+KGN0cjogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gQSk6IGplc3QuTW9ja2VkPEE+IHtcbiAgY29uc3QgcmV0OiBhbnkgPSB7fTtcbiAgZm9yIChjb25zdCBtZXRob2ROYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN0ci5wcm90b3R5cGUpKSB7XG4gICAgcmV0W21ldGhvZE5hbWVdID0gamVzdC5mbigpO1xuICB9XG4gIHJldHVybiByZXQ7XG59Il19