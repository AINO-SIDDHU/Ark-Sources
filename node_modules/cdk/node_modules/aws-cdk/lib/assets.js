"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable-next-line:max-line-length
const asset_schema = require("@aws-cdk/cdk-assets-schema");
const cxapi = require("@aws-cdk/cx-api");
const colors = require("colors");
const path = require("path");
const logging_1 = require("./logging");
/**
 * Take the metadata assets from the given stack and add them to the given asset manifest
 *
 * Returns the CloudFormation parameters that need to be sent to the template to
 * pass Asset coordinates.
 */
// tslint:disable-next-line:max-line-length
async function addMetadataAssetsToManifest(stack, assetManifest, toolkitInfo, reuse) {
    reuse = reuse || [];
    const assets = stack.assets;
    if (assets.length === 0) {
        return {};
    }
    if (!toolkitInfo) {
        // tslint:disable-next-line:max-line-length
        throw new Error(`This stack uses assets, so the toolkit stack must be deployed to the environment (Run "${colors.blue('cdk bootstrap ' + stack.environment.name)}")`);
    }
    const params = {};
    for (const asset of assets) {
        // FIXME: Should have excluded by construct path here instead of by unique ID, preferably using
        // minimatch so we can support globs. Maybe take up during artifact refactoring.
        const reuseAsset = reuse.indexOf(asset.id) > -1;
        if (reuseAsset) {
            logging_1.debug(`Reusing asset ${asset.id}: ${JSON.stringify(asset)}`);
            continue;
        }
        logging_1.debug(`Preparing asset ${asset.id}: ${JSON.stringify(asset)}`);
        if (!stack.assembly) {
            throw new Error('Unexpected: stack assembly is required in order to find assets in assemly directory');
        }
        Object.assign(params, await prepareAsset(asset, assetManifest, toolkitInfo));
    }
    return params;
}
exports.addMetadataAssetsToManifest = addMetadataAssetsToManifest;
// tslint:disable-next-line:max-line-length
async function prepareAsset(asset, assetManifest, toolkitInfo) {
    switch (asset.packaging) {
        case 'zip':
        case 'file':
            return prepareFileAsset(asset, assetManifest, toolkitInfo, asset.packaging === 'zip' ? asset_schema.FileAssetPackaging.ZIP_DIRECTORY : asset_schema.FileAssetPackaging.FILE);
        case 'container-image':
            return await prepareDockerImageAsset(asset, assetManifest, toolkitInfo);
        default:
            // tslint:disable-next-line:max-line-length
            throw new Error(`Unsupported packaging type: ${asset.packaging}. You might need to upgrade your aws-cdk toolkit to support this asset type.`);
    }
}
function prepareFileAsset(asset, assetManifest, toolkitInfo, packaging) {
    const extension = packaging === asset_schema.FileAssetPackaging.ZIP_DIRECTORY ? '.zip' : path.extname(asset.path);
    const baseName = `${asset.sourceHash}${extension}`;
    // Simplify key: assets/abcdef/abcdef.zip is kinda silly and unnecessary, so if they're the same just pick one component.
    const s3Prefix = asset.id === asset.sourceHash ? 'assets/' : `assets/${asset.id}/`;
    const key = `${s3Prefix}${baseName}`;
    const s3url = `s3://${toolkitInfo.bucketName}/${key}`;
    logging_1.debug(`Storing asset ${asset.path} at ${s3url}`);
    assetManifest.addFileAsset(asset.sourceHash, {
        path: asset.path,
        packaging
    }, {
        bucketName: toolkitInfo.bucketName,
        objectKey: key,
    });
    return {
        [asset.s3BucketParameter]: toolkitInfo.bucketName,
        [asset.s3KeyParameter]: `${s3Prefix}${cxapi.ASSET_PREFIX_SEPARATOR}${baseName}`,
        [asset.artifactHashParameter]: asset.sourceHash,
    };
}
async function prepareDockerImageAsset(asset, assetManifest, toolkitInfo) {
    var _a, _b;
    // Pre-1.21.0, repositoryName can be specified by the user or can be left out, in which case we make
    // a per-asset repository which will get adopted and cleaned up along with the stack.
    // Post-1.21.0, repositoryName will always be specified and it will be a shared repository between
    // all assets, and asset will have imageTag specified as well. Validate the combination.
    if (!asset.imageNameParameter && (!asset.repositoryName || !asset.imageTag)) {
        throw new Error('Invalid Docker image asset configuration: "repositoryName" and "imageTag" are required when "imageNameParameter" is left out');
    }
    const repositoryName = (_a = asset.repositoryName) !== null && _a !== void 0 ? _a : 'cdk/' + asset.id.replace(/[:/]/g, '-').toLowerCase();
    // Make sure the repository exists, since the 'cdk-assets' tool will not create it for us.
    const { repositoryUri } = await toolkitInfo.prepareEcrRepository(repositoryName);
    const imageTag = (_b = asset.imageTag) !== null && _b !== void 0 ? _b : asset.sourceHash;
    assetManifest.addDockerImageAsset(asset.sourceHash, {
        directory: asset.path,
        dockerBuildArgs: asset.buildArgs,
        dockerBuildTarget: asset.target,
        dockerFile: asset.file
    }, {
        repositoryName,
        imageTag,
    });
    if (!asset.imageNameParameter) {
        return {};
    }
    return { [asset.imageNameParameter]: `${repositoryUri}:${imageTag}` };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZXRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXNzZXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMkNBQTJDO0FBQzNDLDJEQUEyRDtBQUMzRCx5Q0FBeUM7QUFDekMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUU3Qix1Q0FBa0M7QUFHbEM7Ozs7O0dBS0c7QUFDSCwyQ0FBMkM7QUFDcEMsS0FBSyxVQUFVLDJCQUEyQixDQUFDLEtBQXdDLEVBQUUsYUFBbUMsRUFBRSxXQUF5QixFQUFFLEtBQWdCO0lBQzFLLEtBQUssR0FBRyxLQUFLLElBQUksRUFBRSxDQUFDO0lBQ3BCLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFFNUIsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUN2QixPQUFPLEVBQUUsQ0FBQztLQUNYO0lBRUQsSUFBSSxDQUFDLFdBQVcsRUFBRTtRQUNoQiwyQ0FBMkM7UUFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQywwRkFBMEYsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsV0FBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN4SztJQUVELE1BQU0sTUFBTSxHQUEyQixFQUFFLENBQUM7SUFFMUMsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUU7UUFDMUIsK0ZBQStGO1FBQy9GLGdGQUFnRjtRQUNoRixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUVoRCxJQUFJLFVBQVUsRUFBRTtZQUNkLGVBQUssQ0FBQyxpQkFBaUIsS0FBSyxDQUFDLEVBQUUsS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM3RCxTQUFTO1NBQ1Y7UUFFRCxlQUFLLENBQUMsbUJBQW1CLEtBQUssQ0FBQyxFQUFF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RjtJQUNyRixrR0FBa0c7SUFDbEcsd0ZBQXdGO0lBQ3hGLElBQUksQ0FBQyxLQUFLLENBQUMsa0JBQWtCLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxjQUFjLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUU7UUFDM0UsTUFBTSxJQUFJLEtBQUssQ0FBQyw4SEFBOEgsQ0FBQyxDQUFDO0tBQ2pKO0lBRUQsTUFBTSxjQUFjLFNBQUcsS0FBSyxDQUFDLGNBQWMsbUNBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUVyRywwRkFBMEY7SUFDMUYsTUFBTSxFQUFFLGFBQWEsRUFBRSxHQUFHLE1BQU0sV0FBVyxDQUFDLG9CQUFvQixDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQ2pGLE1BQU0sUUFBUSxTQUFHLEtBQUssQ0FBQyxRQUFRLG1DQUFJLEtBQUssQ0FBQyxVQUFVLENBQUM7SUFFcEQsYUFBYSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUU7UUFDbEQsU0FBUyxFQUFFLEtBQUssQ0FBQyxJQUFJO1FBQ3JCLGVBQWUsRUFBRSxLQUFLLENBQUMsU0FBUztRQUNoQyxpQkFBaUIsRUFBRSxLQUFLLENBQUMsTUFBTTtRQUMvQixVQUFVLEVBQUUsS0FBSyxDQUFDLElBQUk7S0FDdkIsRUFBRTtRQUNELGNBQWM7UUFDZCxRQUFRO0tBQ1QsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsRUFBRTtRQUFFLE9BQU8sRUFBRSxDQUFDO0tBQUU7SUFDN0MsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLEVBQUUsR0FBRyxhQUFhLElBQUksUUFBUSxFQUFFLEVBQUUsQ0FBQztBQUN4RSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuaW1wb3J0ICogYXMgYXNzZXRfc2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nkay1hc3NldHMtc2NoZW1hJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBUb29sa2l0SW5mbyB9IGZyb20gJy4vYXBpL3Rvb2xraXQtaW5mbyc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4vbG9nZ2luZyc7XG5pbXBvcnQgeyBBc3NldE1hbmlmZXN0QnVpbGRlciB9IGZyb20gJy4vdXRpbC9hc3NldC1tYW5pZmVzdC1idWlsZGVyJztcblxuLyoqXG4gKiBUYWtlIHRoZSBtZXRhZGF0YSBhc3NldHMgZnJvbSB0aGUgZ2l2ZW4gc3RhY2sgYW5kIGFkZCB0aGVtIHRvIHRoZSBnaXZlbiBhc3NldCBtYW5pZmVzdFxuICpcbiAqIFJldHVybnMgdGhlIENsb3VkRm9ybWF0aW9uIHBhcmFtZXRlcnMgdGhhdCBuZWVkIHRvIGJlIHNlbnQgdG8gdGhlIHRlbXBsYXRlIHRvXG4gKiBwYXNzIEFzc2V0IGNvb3JkaW5hdGVzLlxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkTWV0YWRhdGFBc3NldHNUb01hbmlmZXN0KHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsIGFzc2V0TWFuaWZlc3Q6IEFzc2V0TWFuaWZlc3RCdWlsZGVyLCB0b29sa2l0SW5mbz86IFRvb2xraXRJbmZvLCByZXVzZT86IHN0cmluZ1tdKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB7XG4gIHJldXNlID0gcmV1c2UgfHwgW107XG4gIGNvbnN0IGFzc2V0cyA9IHN0YWNrLmFzc2V0cztcblxuICBpZiAoYXNzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGlmICghdG9vbGtpdEluZm8pIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIHN0YWNrIHVzZXMgYXNzZXRzLCBzbyB0aGUgdG9vbGtpdCBzdGFjayBtdXN0IGJlIGRlcGxveWVkIHRvIHRoZSBlbnZpcm9ubWVudCAoUnVuIFwiJHtjb2xvcnMuYmx1ZSgnY2RrIGJvb3RzdHJhcCAnICsgc3RhY2suZW52aXJvbm1lbnQhLm5hbWUpfVwiKWApO1xuICB9XG5cbiAgY29uc3QgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgZm9yIChjb25zdCBhc3NldCBvZiBhc3NldHMpIHtcbiAgICAvLyBGSVhNRTogU2hvdWxkIGhhdmUgZXhjbHVkZWQgYnkgY29uc3RydWN0IHBhdGggaGVyZSBpbnN0ZWFkIG9mIGJ5IHVuaXF1ZSBJRCwgcHJlZmVyYWJseSB1c2luZ1xuICAgIC8vIG1pbmltYXRjaCBzbyB3ZSBjYW4gc3VwcG9ydCBnbG9icy4gTWF5YmUgdGFrZSB1cCBkdXJpbmcgYXJ0aWZhY3QgcmVmYWN0b3JpbmcuXG4gICAgY29uc3QgcmV1c2VBc3NldCA9IHJldXNlLmluZGV4T2YoYXNzZXQuaWQpID4gLTE7XG5cbiAgICBpZiAocmV1c2VBc3NldCkge1xuICAgICAgZGVidWcoYFJldXNpbmcgYXNzZXQgJHthc3NldC5pZH06ICR7SlNPTi5zdHJpbmdpZnkoYXNzZXQpfWApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZGVidWcoYFByZXBhcmluZyBhc3NldCAke2Fzc2V0LmlkfTogJHtKU09OLnN0cmluZ2lmeShhc3NldCl9YCk7XG4gICAgaWYgKCFzdGFjay5hc3NlbWJseSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkOiBzdGFjayBhc3NlbWJseSBpcyByZXF1aXJlZCBpbiBvcmRlciB0byBmaW5kIGFzc2V0cyBpbiBhc3NlbWx5IGRpcmVjdG9yeScpO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLCBhd2FpdCBwcmVwYXJlQXNzZXQoYXNzZXQsIGFzc2V0TWFuaWZlc3QsIHRvb2xraXRJbmZvKSk7XG4gIH1cblxuICByZXR1cm4gcGFyYW1zO1xufVxuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlQXNzZXQoYXNzZXQ6IGN4YXBpLkFzc2V0TWV0YWRhdGFFbnRyeSwgYXNzZXRNYW5pZmVzdDogQXNzZXRNYW5pZmVzdEJ1aWxkZXIsIHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbyk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4ge1xuICBzd2l0Y2ggKGFzc2V0LnBhY2thZ2luZykge1xuICAgIGNhc2UgJ3ppcCc6XG4gICAgY2FzZSAnZmlsZSc6XG4gICAgICByZXR1cm4gcHJlcGFyZUZpbGVBc3NldChcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIGFzc2V0TWFuaWZlc3QsXG4gICAgICAgIHRvb2xraXRJbmZvLFxuICAgICAgICBhc3NldC5wYWNrYWdpbmcgPT09ICd6aXAnID8gYXNzZXRfc2NoZW1hLkZpbGVBc3NldFBhY2thZ2luZy5aSVBfRElSRUNUT1JZIDogYXNzZXRfc2NoZW1hLkZpbGVBc3NldFBhY2thZ2luZy5GSUxFKTtcbiAgICBjYXNlICdjb250YWluZXItaW1hZ2UnOlxuICAgICAgcmV0dXJuIGF3YWl0IHByZXBhcmVEb2NrZXJJbWFnZUFzc2V0KGFzc2V0LCBhc3NldE1hbmlmZXN0LCB0b29sa2l0SW5mbyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFja2FnaW5nIHR5cGU6ICR7KGFzc2V0IGFzIGFueSkucGFja2FnaW5nfS4gWW91IG1pZ2h0IG5lZWQgdG8gdXBncmFkZSB5b3VyIGF3cy1jZGsgdG9vbGtpdCB0byBzdXBwb3J0IHRoaXMgYXNzZXQgdHlwZS5gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlRmlsZUFzc2V0KFxuICBhc3NldDogY3hhcGkuRmlsZUFzc2V0TWV0YWRhdGFFbnRyeSxcbiAgYXNzZXRNYW5pZmVzdDogQXNzZXRNYW5pZmVzdEJ1aWxkZXIsXG4gIHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbyxcbiAgcGFja2FnaW5nOiBhc3NldF9zY2hlbWEuRmlsZUFzc2V0UGFja2FnaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG5cbiAgY29uc3QgZXh0ZW5zaW9uID0gcGFja2FnaW5nID09PSBhc3NldF9zY2hlbWEuRmlsZUFzc2V0UGFja2FnaW5nLlpJUF9ESVJFQ1RPUlkgPyAnLnppcCcgOiBwYXRoLmV4dG5hbWUoYXNzZXQucGF0aCk7XG4gIGNvbnN0IGJhc2VOYW1lID0gYCR7YXNzZXQuc291cmNlSGFzaH0ke2V4dGVuc2lvbn1gO1xuICAvLyBTaW1wbGlmeSBrZXk6IGFzc2V0cy9hYmNkZWYvYWJjZGVmLnppcCBpcyBraW5kYSBzaWxseSBhbmQgdW5uZWNlc3NhcnksIHNvIGlmIHRoZXkncmUgdGhlIHNhbWUganVzdCBwaWNrIG9uZSBjb21wb25lbnQuXG4gIGNvbnN0IHMzUHJlZml4ID0gYXNzZXQuaWQgPT09IGFzc2V0LnNvdXJjZUhhc2ggPyAnYXNzZXRzLycgOiBgYXNzZXRzLyR7YXNzZXQuaWR9L2A7XG4gIGNvbnN0IGtleSA9IGAke3MzUHJlZml4fSR7YmFzZU5hbWV9YDtcbiAgY29uc3QgczN1cmwgPSBgczM6Ly8ke3Rvb2xraXRJbmZvLmJ1Y2tldE5hbWV9LyR7a2V5fWA7XG5cbiAgZGVidWcoYFN0b3JpbmcgYXNzZXQgJHthc3NldC5wYXRofSBhdCAke3MzdXJsfWApO1xuXG4gIGFzc2V0TWFuaWZlc3QuYWRkRmlsZUFzc2V0KGFzc2V0LnNvdXJjZUhhc2gsIHtcbiAgICBwYXRoOiBhc3NldC5wYXRoLFxuICAgIHBhY2thZ2luZ1xuICB9LCB7XG4gICAgYnVja2V0TmFtZTogdG9vbGtpdEluZm8uYnVja2V0TmFtZSxcbiAgICBvYmplY3RLZXk6IGtleSxcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBbYXNzZXQuczNCdWNrZXRQYXJhbWV0ZXJdOiB0b29sa2l0SW5mby5idWNrZXROYW1lLFxuICAgIFthc3NldC5zM0tleVBhcmFtZXRlcl06IGAke3MzUHJlZml4fSR7Y3hhcGkuQVNTRVRfUFJFRklYX1NFUEFSQVRPUn0ke2Jhc2VOYW1lfWAsXG4gICAgW2Fzc2V0LmFydGlmYWN0SGFzaFBhcmFtZXRlcl06IGFzc2V0LnNvdXJjZUhhc2gsXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVEb2NrZXJJbWFnZUFzc2V0KFxuICBhc3NldDogY3hhcGkuQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnksXG4gIGFzc2V0TWFuaWZlc3Q6IEFzc2V0TWFuaWZlc3RCdWlsZGVyLFxuICB0b29sa2l0SW5mbzogVG9vbGtpdEluZm8pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+IHtcblxuICAvLyBQcmUtMS4yMS4wLCByZXBvc2l0b3J5TmFtZSBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIG9yIGNhbiBiZSBsZWZ0IG91dCwgaW4gd2hpY2ggY2FzZSB3ZSBtYWtlXG4gIC8vIGEgcGVyLWFzc2V0IHJlcG9zaXRvcnkgd2hpY2ggd2lsbCBnZXQgYWRvcHRlZCBhbmQgY2xlYW5lZCB1cCBhbG9uZyB3aXRoIHRoZSBzdGFjay5cbiAgLy8gUG9zdC0xLjIxLjAsIHJlcG9zaXRvcnlOYW1lIHdpbGwgYWx3YXlzIGJlIHNwZWNpZmllZCBhbmQgaXQgd2lsbCBiZSBhIHNoYXJlZCByZXBvc2l0b3J5IGJldHdlZW5cbiAgLy8gYWxsIGFzc2V0cywgYW5kIGFzc2V0IHdpbGwgaGF2ZSBpbWFnZVRhZyBzcGVjaWZpZWQgYXMgd2VsbC4gVmFsaWRhdGUgdGhlIGNvbWJpbmF0aW9uLlxuICBpZiAoIWFzc2V0LmltYWdlTmFtZVBhcmFtZXRlciAmJiAoIWFzc2V0LnJlcG9zaXRvcnlOYW1lIHx8ICFhc3NldC5pbWFnZVRhZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRG9ja2VyIGltYWdlIGFzc2V0IGNvbmZpZ3VyYXRpb246IFwicmVwb3NpdG9yeU5hbWVcIiBhbmQgXCJpbWFnZVRhZ1wiIGFyZSByZXF1aXJlZCB3aGVuIFwiaW1hZ2VOYW1lUGFyYW1ldGVyXCIgaXMgbGVmdCBvdXQnKTtcbiAgfVxuXG4gIGNvbnN0IHJlcG9zaXRvcnlOYW1lID0gYXNzZXQucmVwb3NpdG9yeU5hbWUgPz8gJ2Nkay8nICsgYXNzZXQuaWQucmVwbGFjZSgvWzovXS9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSByZXBvc2l0b3J5IGV4aXN0cywgc2luY2UgdGhlICdjZGstYXNzZXRzJyB0b29sIHdpbGwgbm90IGNyZWF0ZSBpdCBmb3IgdXMuXG4gIGNvbnN0IHsgcmVwb3NpdG9yeVVyaSB9ID0gYXdhaXQgdG9vbGtpdEluZm8ucHJlcGFyZUVjclJlcG9zaXRvcnkocmVwb3NpdG9yeU5hbWUpO1xuICBjb25zdCBpbWFnZVRhZyA9IGFzc2V0LmltYWdlVGFnID8/IGFzc2V0LnNvdXJjZUhhc2g7XG5cbiAgYXNzZXRNYW5pZmVzdC5hZGREb2NrZXJJbWFnZUFzc2V0KGFzc2V0LnNvdXJjZUhhc2gsIHtcbiAgICBkaXJlY3Rvcnk6IGFzc2V0LnBhdGgsXG4gICAgZG9ja2VyQnVpbGRBcmdzOiBhc3NldC5idWlsZEFyZ3MsXG4gICAgZG9ja2VyQnVpbGRUYXJnZXQ6IGFzc2V0LnRhcmdldCxcbiAgICBkb2NrZXJGaWxlOiBhc3NldC5maWxlXG4gIH0sIHtcbiAgICByZXBvc2l0b3J5TmFtZSxcbiAgICBpbWFnZVRhZyxcbiAgfSk7XG5cbiAgaWYgKCFhc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXIpIHsgcmV0dXJuIHt9OyB9XG4gIHJldHVybiB7IFthc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXJdOiBgJHtyZXBvc2l0b3J5VXJpfToke2ltYWdlVGFnfWAgfTtcbn0iXX0=