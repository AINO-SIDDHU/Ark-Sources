"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const childProcess = require("child_process");
const fs = require("fs-extra");
const path = require("path");
const logging_1 = require("../../logging");
const settings_1 = require("../../settings");
const version_1 = require("../../version");
/** Invokes the cloud executable and returns JSON output */
async function execProgram(aws, config) {
    const env = {};
    const context = config.context.all;
    await populateDefaultEnvironmentIfNeeded(aws, env);
    let pathMetadata = config.settings.get(['pathMetadata']);
    if (pathMetadata === undefined) {
        pathMetadata = true; // defaults to true
    }
    if (pathMetadata) {
        context[cxapi.PATH_METADATA_ENABLE_CONTEXT] = true;
    }
    let assetMetadata = config.settings.get(['assetMetadata']);
    if (assetMetadata === undefined) {
        assetMetadata = true; // defaults to true
    }
    if (assetMetadata) {
        context[cxapi.ASSET_RESOURCE_METADATA_ENABLED_CONTEXT] = true;
    }
    let versionReporting = config.settings.get(['versionReporting']);
    if (versionReporting === undefined) {
        versionReporting = true; // defaults to true
    }
    if (!versionReporting) {
        context[cxapi.DISABLE_VERSION_REPORTING] = true;
    }
    let stagingEnabled = config.settings.get(['staging']);
    if (stagingEnabled === undefined) {
        stagingEnabled = true;
    }
    if (!stagingEnabled) {
        context[cxapi.DISABLE_ASSET_STAGING_CONTEXT] = true;
    }
    logging_1.debug('context:', context);
    env[cxapi.CONTEXT_ENV] = JSON.stringify(context);
    const app = config.settings.get(['app']);
    if (!app) {
        throw new Error(`--app is required either in command-line, in ${settings_1.PROJECT_CONFIG} or in ${settings_1.USER_DEFAULTS}`);
    }
    // by pass "synth" if app points to a cloud assembly
    if (await fs.pathExists(app) && (await fs.stat(app)).isDirectory()) {
        logging_1.debug('--app points to a cloud assembly, so we by pass synth');
        return new cxapi.CloudAssembly(app);
    }
    const commandLine = await guessExecutable(appToArray(app));
    const outdir = config.settings.get(['output']);
    if (!outdir) {
        throw new Error('unexpected: --output is required');
    }
    await fs.mkdirp(outdir);
    logging_1.debug('outdir:', outdir);
    env[cxapi.OUTDIR_ENV] = outdir;
    // Send version information
    env[cxapi.CLI_ASM_VERSION_ENV] = cxapi.CLOUD_ASSEMBLY_VERSION;
    env[cxapi.CLI_VERSION_ENV] = version_1.versionNumber();
    logging_1.debug('env:', env);
    await exec();
    return new cxapi.CloudAssembly(outdir);
    async function exec() {
        return new Promise((ok, fail) => {
            // We use a slightly lower-level interface to:
            //
            // - Pass arguments in an array instead of a string, to get around a
            //   number of quoting issues introduced by the intermediate shell layer
            //   (which would be different between Linux and Windows).
            //
            // - Inherit stderr from controlling terminal. We don't use the captured value
            //   anway, and if the subprocess is printing to it for debugging purposes the
            //   user gets to see it sooner. Plus, capturing doesn't interact nicely with some
            //   processes like Maven.
            const proc = childProcess.spawn(commandLine[0], commandLine.slice(1), {
                stdio: ['ignore', 'inherit', 'inherit'],
                detached: false,
                shell: true,
                env: {
                    ...process.env,
                    ...env
                }
            });
            proc.on('error', fail);
            proc.on('exit', code => {
                if (code === 0) {
                    return ok();
                }
                else {
                    return fail(new Error(`Subprocess exited with error ${code}`));
                }
            });
        });
    }
}
exports.execProgram = execProgram;
/**
 * If we don't have region/account defined in context, we fall back to the default SDK behavior
 * where region is retreived from ~/.aws/config and account is based on default credentials provider
 * chain and then STS is queried.
 *
 * This is done opportunistically: for example, if we can't acccess STS for some reason or the region
 * is not configured, the context value will be 'null' and there could failures down the line. In
 * some cases, synthesis does not require region/account information at all, so that might be perfectly
 * fine in certain scenarios.
 *
 * @param context The context key/value bash.
 */
async function populateDefaultEnvironmentIfNeeded(aws, env) {
    var _a;
    env[cxapi.DEFAULT_REGION_ENV] = aws.defaultRegion;
    logging_1.debug(`Setting "${cxapi.DEFAULT_REGION_ENV}" environment variable to`, env[cxapi.DEFAULT_REGION_ENV]);
    const accountId = (_a = (await aws.defaultAccount())) === null || _a === void 0 ? void 0 : _a.accountId;
    if (accountId) {
        env[cxapi.DEFAULT_ACCOUNT_ENV] = accountId;
        logging_1.debug(`Setting "${cxapi.DEFAULT_ACCOUNT_ENV}" environment variable to`, env[cxapi.DEFAULT_ACCOUNT_ENV]);
    }
}
/**
 * Make sure the 'app' is an array
 *
 * If it's a string, split on spaces as a trivial way of tokenizing the command line.
 */
function appToArray(app) {
    return typeof app === 'string' ? app.split(' ') : app;
}
/**
 * Execute the given file with the same 'node' process as is running the current process
 */
function executeNode(scriptFile) {
    return [process.execPath, scriptFile];
}
/**
 * Mapping of extensions to command-line generators
 */
const EXTENSION_MAP = new Map([
    ['.js', executeNode],
]);
/**
 * Guess the executable from the command-line argument
 *
 * Only do this if the file is NOT marked as executable. If it is,
 * we'll defer to the shebang inside the file itself.
 *
 * If we're on Windows, we ALWAYS take the handler, since it's hard to
 * verify if registry associations have or have not been set up for this
 * file type, so we'll assume the worst and take control.
 */
async function guessExecutable(commandLine) {
    if (commandLine.length === 1) {
        const fstat = await fs.stat(commandLine[0]);
        // tslint:disable-next-line:no-bitwise
        const isExecutable = (fstat.mode & fs.constants.X_OK) !== 0;
        const isWindows = process.platform === 'win32';
        const handler = EXTENSION_MAP.get(path.extname(commandLine[0]));
        if (handler && (!isExecutable || isWindows)) {
            return handler(commandLine[0]);
        }
    }
    return commandLine;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImV4ZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5Q0FBeUM7QUFDekMsOENBQThDO0FBQzlDLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsMkNBQXNDO0FBQ3RDLDZDQUE4RTtBQUM5RSwyQ0FBOEM7QUFHOUMsMkRBQTJEO0FBQ3BELEtBQUssVUFBVSxXQUFXLENBQUMsR0FBZ0IsRUFBRSxNQUFxQjtJQUN2RSxNQUFNLEdBQUcsR0FBOEIsRUFBRyxDQUFDO0lBRTNDLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0lBQ25DLE1BQU0sa0NBQWtDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBRW5ELElBQUksWUFBWSxHQUFZLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztJQUNsRSxJQUFJLFlBQVksS0FBSyxTQUFTLEVBQUU7UUFDOUIsWUFBWSxHQUFHLElBQUksQ0FBQyxDQUFDLG1CQUFtQjtLQUN6QztJQUVELElBQUksWUFBWSxFQUFFO1FBQ2hCLE9BQU8sQ0FBQyxLQUFLLENBQUMsNEJBQTRCLENBQUMsR0FBRyxJQUFJLENBQUM7S0FDcEQ7SUFFRCxJQUFJLGFBQWEsR0FBWSxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7SUFDcEUsSUFBSSxhQUFhLEtBQUssU0FBUyxFQUFFO1FBQy9CLGFBQWEsR0FBRyxJQUFJLENBQUMsQ0FBQyxtQkFBbUI7S0FDMUM7SUFFRCxJQUFJLGFBQWEsRUFBRTtRQUNqQixPQUFPLENBQUMsS0FBSyxDQUFDLHVDQUF1QyxDQUFDLEdBQUcsSUFBSSxDQUFDO0tBQy9EO0lBRUQsSUFBSSxnQkFBZ0IsR0FBWSxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztJQUMxRSxJQUFJLGdCQUFnQixLQUFLLFNBQVMsRUFBRTtRQUNsQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsQ0FBQyxtQkFBbUI7S0FDN0M7SUFFRCxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7UUFDckIsT0FBTyxDQUFDLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHLElBQUksQ0FBQztLQUNqRDtJQUVELElBQUksY0FBYyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUN0RCxJQUFJLGNBQWMsS0FBSyxTQUFTLEVBQUU7UUFDaEMsY0FBYyxHQUFHLElBQUksQ0FBQztLQUN2QjtJQUNELElBQUksQ0FBQyxjQUFjLEVBQUU7UUFDbkIsT0FBTyxDQUFDLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxHQUFHLElBQUksQ0FBQztLQUNyRDtJQUVELGVBQUssQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDM0IsR0FBRyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRWpELE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN6QyxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ1IsTUFBTSxJQUFJLEtBQUssQ0FBQyxnREFBZ0QseUJBQWMsVUFBVSx3QkFBYSxFQUFFLENBQUMsQ0FBQztLQUMxRztJQUVELG9EQUFvRDtJQUNwRCxJQUFJLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFO1FBQ2xFLGVBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO1FBQy9ELE9BQU8sSUFBSSxLQUFLLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ3JDO0lBRUQsTUFBTSxXQUFXLEdBQUcsTUFBTSxlQUFlLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFFM0QsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBRSxRQUFRLENBQUUsQ0FBQyxDQUFDO0lBQ2pELElBQUksQ0FBQyxNQUFNLEVBQUU7UUFDWCxNQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7S0FDckQ7SUFDRCxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFFeEIsZUFBSyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUN6QixHQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLE1BQU0sQ0FBQztJQUUvQiwyQkFBMkI7SUFDM0IsR0FBRyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQztJQUM5RCxHQUFHLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxHQUFHLHVCQUFhLEVBQUUsQ0FBQztJQUU3QyxlQUFLLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBRW5CLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFFYixPQUFPLElBQUksS0FBSyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUV2QyxLQUFLLFVBQVUsSUFBSTtRQUNqQixPQUFPLElBQUksT0FBTyxDQUFTLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFO1lBQ3RDLDhDQUE4QztZQUM5QyxFQUFFO1lBQ0Ysb0VBQW9FO1lBQ3BFLHdFQUF3RTtZQUN4RSwwREFBMEQ7WUFDMUQsRUFBRTtZQUNGLDhFQUE4RTtZQUM5RSw4RUFBOEU7WUFDOUUsa0ZBQWtGO1lBQ2xGLDBCQUEwQjtZQUMxQixNQUFNLElBQUksR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNwRSxLQUFLLEVBQUUsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQztnQkFDdkMsUUFBUSxFQUFFLEtBQUs7Z0JBQ2YsS0FBSyxFQUFFLElBQUk7Z0JBQ1gsR0FBRyxFQUFFO29CQUNILEdBQUcsT0FBTyxDQUFDLEdBQUc7b0JBQ2QsR0FBRyxHQUFHO2lCQUNQO2FBQ0YsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFdkIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUU7Z0JBQ3JCLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRTtvQkFDZCxPQUFPLEVBQUUsRUFBRSxDQUFDO2lCQUNiO3FCQUFNO29CQUNMLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxDQUFDLGdDQUFnQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQ2hFO1lBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7QUFDSCxDQUFDO0FBN0dELGtDQTZHQztBQUVEOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsS0FBSyxVQUFVLGtDQUFrQyxDQUFDLEdBQWdCLEVBQUUsR0FBeUM7O0lBQzNHLEdBQUcsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsR0FBRyxHQUFHLENBQUMsYUFBYSxDQUFDO0lBQ2xELGVBQUssQ0FBQyxZQUFZLEtBQUssQ0FBQyxrQkFBa0IsMkJBQTJCLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7SUFFdEcsTUFBTSxTQUFTLFNBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQywwQ0FBRSxTQUFTLENBQUM7SUFDMUQsSUFBSSxTQUFTLEVBQUU7UUFDYixHQUFHLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLEdBQUcsU0FBUyxDQUFDO1FBQzNDLGVBQUssQ0FBQyxZQUFZLEtBQUssQ0FBQyxtQkFBbUIsMkJBQTJCLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7S0FDekc7QUFDSCxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsVUFBVSxDQUFDLEdBQVE7SUFDMUIsT0FBTyxPQUFPLEdBQUcsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUN4RCxDQUFDO0FBSUQ7O0dBRUc7QUFDSCxTQUFTLFdBQVcsQ0FBQyxVQUFrQjtJQUNyQyxPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLGFBQWEsR0FBRyxJQUFJLEdBQUcsQ0FBMkI7SUFDdEQsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDO0NBQ3JCLENBQUMsQ0FBQztBQUVIOzs7Ozs7Ozs7R0FTRztBQUNILEtBQUssVUFBVSxlQUFlLENBQUMsV0FBcUI7SUFDbEQsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUM1QixNQUFNLEtBQUssR0FBRyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUMsc0NBQXNDO1FBQ3RDLE1BQU0sWUFBWSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM1RCxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsUUFBUSxLQUFLLE9BQU8sQ0FBQztRQUUvQyxNQUFNLE9BQU8sR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoRSxJQUFJLE9BQU8sSUFBSSxDQUFDLENBQUMsWUFBWSxJQUFJLFNBQVMsQ0FBQyxFQUFFO1lBQzNDLE9BQU8sT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2hDO0tBQ0Y7SUFDRCxPQUFPLFdBQVcsQ0FBQztBQUNyQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoaWxkUHJvY2VzcyBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgQ29uZmlndXJhdGlvbiwgUFJPSkVDVF9DT05GSUcsIFVTRVJfREVGQVVMVFMgfSBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyB2ZXJzaW9uTnVtYmVyIH0gZnJvbSAnLi4vLi4vdmVyc2lvbic7XG5pbXBvcnQgeyBTZGtQcm92aWRlciB9IGZyb20gJy4uL2F3cy1hdXRoJztcblxuLyoqIEludm9rZXMgdGhlIGNsb3VkIGV4ZWN1dGFibGUgYW5kIHJldHVybnMgSlNPTiBvdXRwdXQgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjUHJvZ3JhbShhd3M6IFNka1Byb3ZpZGVyLCBjb25maWc6IENvbmZpZ3VyYXRpb24pOiBQcm9taXNlPGN4YXBpLkNsb3VkQXNzZW1ibHk+IHtcbiAgY29uc3QgZW52OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0geyB9O1xuXG4gIGNvbnN0IGNvbnRleHQgPSBjb25maWcuY29udGV4dC5hbGw7XG4gIGF3YWl0IHBvcHVsYXRlRGVmYXVsdEVudmlyb25tZW50SWZOZWVkZWQoYXdzLCBlbnYpO1xuXG4gIGxldCBwYXRoTWV0YWRhdGE6IGJvb2xlYW4gPSBjb25maWcuc2V0dGluZ3MuZ2V0KFsncGF0aE1ldGFkYXRhJ10pO1xuICBpZiAocGF0aE1ldGFkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBwYXRoTWV0YWRhdGEgPSB0cnVlOyAvLyBkZWZhdWx0cyB0byB0cnVlXG4gIH1cblxuICBpZiAocGF0aE1ldGFkYXRhKSB7XG4gICAgY29udGV4dFtjeGFwaS5QQVRIX01FVEFEQVRBX0VOQUJMRV9DT05URVhUXSA9IHRydWU7XG4gIH1cblxuICBsZXQgYXNzZXRNZXRhZGF0YTogYm9vbGVhbiA9IGNvbmZpZy5zZXR0aW5ncy5nZXQoWydhc3NldE1ldGFkYXRhJ10pO1xuICBpZiAoYXNzZXRNZXRhZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXRNZXRhZGF0YSA9IHRydWU7IC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgfVxuXG4gIGlmIChhc3NldE1ldGFkYXRhKSB7XG4gICAgY29udGV4dFtjeGFwaS5BU1NFVF9SRVNPVVJDRV9NRVRBREFUQV9FTkFCTEVEX0NPTlRFWFRdID0gdHJ1ZTtcbiAgfVxuXG4gIGxldCB2ZXJzaW9uUmVwb3J0aW5nOiBib29sZWFuID0gY29uZmlnLnNldHRpbmdzLmdldChbJ3ZlcnNpb25SZXBvcnRpbmcnXSk7XG4gIGlmICh2ZXJzaW9uUmVwb3J0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICB2ZXJzaW9uUmVwb3J0aW5nID0gdHJ1ZTsgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICB9XG5cbiAgaWYgKCF2ZXJzaW9uUmVwb3J0aW5nKSB7XG4gICAgY29udGV4dFtjeGFwaS5ESVNBQkxFX1ZFUlNJT05fUkVQT1JUSU5HXSA9IHRydWU7XG4gIH1cblxuICBsZXQgc3RhZ2luZ0VuYWJsZWQgPSBjb25maWcuc2V0dGluZ3MuZ2V0KFsnc3RhZ2luZyddKTtcbiAgaWYgKHN0YWdpbmdFbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFnaW5nRW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgaWYgKCFzdGFnaW5nRW5hYmxlZCkge1xuICAgIGNvbnRleHRbY3hhcGkuRElTQUJMRV9BU1NFVF9TVEFHSU5HX0NPTlRFWFRdID0gdHJ1ZTtcbiAgfVxuXG4gIGRlYnVnKCdjb250ZXh0OicsIGNvbnRleHQpO1xuICBlbnZbY3hhcGkuQ09OVEVYVF9FTlZdID0gSlNPTi5zdHJpbmdpZnkoY29udGV4dCk7XG5cbiAgY29uc3QgYXBwID0gY29uZmlnLnNldHRpbmdzLmdldChbJ2FwcCddKTtcbiAgaWYgKCFhcHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYC0tYXBwIGlzIHJlcXVpcmVkIGVpdGhlciBpbiBjb21tYW5kLWxpbmUsIGluICR7UFJPSkVDVF9DT05GSUd9IG9yIGluICR7VVNFUl9ERUZBVUxUU31gKTtcbiAgfVxuXG4gIC8vIGJ5IHBhc3MgXCJzeW50aFwiIGlmIGFwcCBwb2ludHMgdG8gYSBjbG91ZCBhc3NlbWJseVxuICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhhcHApICYmIChhd2FpdCBmcy5zdGF0KGFwcCkpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBkZWJ1ZygnLS1hcHAgcG9pbnRzIHRvIGEgY2xvdWQgYXNzZW1ibHksIHNvIHdlIGJ5IHBhc3Mgc3ludGgnKTtcbiAgICByZXR1cm4gbmV3IGN4YXBpLkNsb3VkQXNzZW1ibHkoYXBwKTtcbiAgfVxuXG4gIGNvbnN0IGNvbW1hbmRMaW5lID0gYXdhaXQgZ3Vlc3NFeGVjdXRhYmxlKGFwcFRvQXJyYXkoYXBwKSk7XG5cbiAgY29uc3Qgb3V0ZGlyID0gY29uZmlnLnNldHRpbmdzLmdldChbICdvdXRwdXQnIF0pO1xuICBpZiAoIW91dGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZDogLS1vdXRwdXQgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICBhd2FpdCBmcy5ta2RpcnAob3V0ZGlyKTtcblxuICBkZWJ1Zygnb3V0ZGlyOicsIG91dGRpcik7XG4gIGVudltjeGFwaS5PVVRESVJfRU5WXSA9IG91dGRpcjtcblxuICAvLyBTZW5kIHZlcnNpb24gaW5mb3JtYXRpb25cbiAgZW52W2N4YXBpLkNMSV9BU01fVkVSU0lPTl9FTlZdID0gY3hhcGkuQ0xPVURfQVNTRU1CTFlfVkVSU0lPTjtcbiAgZW52W2N4YXBpLkNMSV9WRVJTSU9OX0VOVl0gPSB2ZXJzaW9uTnVtYmVyKCk7XG5cbiAgZGVidWcoJ2VudjonLCBlbnYpO1xuXG4gIGF3YWl0IGV4ZWMoKTtcblxuICByZXR1cm4gbmV3IGN4YXBpLkNsb3VkQXNzZW1ibHkob3V0ZGlyKTtcblxuICBhc3luYyBmdW5jdGlvbiBleGVjKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChvaywgZmFpbCkgPT4ge1xuICAgICAgLy8gV2UgdXNlIGEgc2xpZ2h0bHkgbG93ZXItbGV2ZWwgaW50ZXJmYWNlIHRvOlxuICAgICAgLy9cbiAgICAgIC8vIC0gUGFzcyBhcmd1bWVudHMgaW4gYW4gYXJyYXkgaW5zdGVhZCBvZiBhIHN0cmluZywgdG8gZ2V0IGFyb3VuZCBhXG4gICAgICAvLyAgIG51bWJlciBvZiBxdW90aW5nIGlzc3VlcyBpbnRyb2R1Y2VkIGJ5IHRoZSBpbnRlcm1lZGlhdGUgc2hlbGwgbGF5ZXJcbiAgICAgIC8vICAgKHdoaWNoIHdvdWxkIGJlIGRpZmZlcmVudCBiZXR3ZWVuIExpbnV4IGFuZCBXaW5kb3dzKS5cbiAgICAgIC8vXG4gICAgICAvLyAtIEluaGVyaXQgc3RkZXJyIGZyb20gY29udHJvbGxpbmcgdGVybWluYWwuIFdlIGRvbid0IHVzZSB0aGUgY2FwdHVyZWQgdmFsdWVcbiAgICAgIC8vICAgYW53YXksIGFuZCBpZiB0aGUgc3VicHJvY2VzcyBpcyBwcmludGluZyB0byBpdCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzIHRoZVxuICAgICAgLy8gICB1c2VyIGdldHMgdG8gc2VlIGl0IHNvb25lci4gUGx1cywgY2FwdHVyaW5nIGRvZXNuJ3QgaW50ZXJhY3QgbmljZWx5IHdpdGggc29tZVxuICAgICAgLy8gICBwcm9jZXNzZXMgbGlrZSBNYXZlbi5cbiAgICAgIGNvbnN0IHByb2MgPSBjaGlsZFByb2Nlc3Muc3Bhd24oY29tbWFuZExpbmVbMF0sIGNvbW1hbmRMaW5lLnNsaWNlKDEpLCB7XG4gICAgICAgIHN0ZGlvOiBbJ2lnbm9yZScsICdpbmhlcml0JywgJ2luaGVyaXQnXSxcbiAgICAgICAgZGV0YWNoZWQ6IGZhbHNlLFxuICAgICAgICBzaGVsbDogdHJ1ZSxcbiAgICAgICAgZW52OiB7XG4gICAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAgICAgLi4uZW52XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBwcm9jLm9uKCdlcnJvcicsIGZhaWwpO1xuXG4gICAgICBwcm9jLm9uKCdleGl0JywgY29kZSA9PiB7XG4gICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG9rKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhaWwobmV3IEVycm9yKGBTdWJwcm9jZXNzIGV4aXRlZCB3aXRoIGVycm9yICR7Y29kZX1gKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogSWYgd2UgZG9uJ3QgaGF2ZSByZWdpb24vYWNjb3VudCBkZWZpbmVkIGluIGNvbnRleHQsIHdlIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCBTREsgYmVoYXZpb3JcbiAqIHdoZXJlIHJlZ2lvbiBpcyByZXRyZWl2ZWQgZnJvbSB+Ly5hd3MvY29uZmlnIGFuZCBhY2NvdW50IGlzIGJhc2VkIG9uIGRlZmF1bHQgY3JlZGVudGlhbHMgcHJvdmlkZXJcbiAqIGNoYWluIGFuZCB0aGVuIFNUUyBpcyBxdWVyaWVkLlxuICpcbiAqIFRoaXMgaXMgZG9uZSBvcHBvcnR1bmlzdGljYWxseTogZm9yIGV4YW1wbGUsIGlmIHdlIGNhbid0IGFjY2Nlc3MgU1RTIGZvciBzb21lIHJlYXNvbiBvciB0aGUgcmVnaW9uXG4gKiBpcyBub3QgY29uZmlndXJlZCwgdGhlIGNvbnRleHQgdmFsdWUgd2lsbCBiZSAnbnVsbCcgYW5kIHRoZXJlIGNvdWxkIGZhaWx1cmVzIGRvd24gdGhlIGxpbmUuIEluXG4gKiBzb21lIGNhc2VzLCBzeW50aGVzaXMgZG9lcyBub3QgcmVxdWlyZSByZWdpb24vYWNjb3VudCBpbmZvcm1hdGlvbiBhdCBhbGwsIHNvIHRoYXQgbWlnaHQgYmUgcGVyZmVjdGx5XG4gKiBmaW5lIGluIGNlcnRhaW4gc2NlbmFyaW9zLlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IGtleS92YWx1ZSBiYXNoLlxuICovXG5hc3luYyBmdW5jdGlvbiBwb3B1bGF0ZURlZmF1bHRFbnZpcm9ubWVudElmTmVlZGVkKGF3czogU2RrUHJvdmlkZXIsIGVudjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWR9KSB7XG4gIGVudltjeGFwaS5ERUZBVUxUX1JFR0lPTl9FTlZdID0gYXdzLmRlZmF1bHRSZWdpb247XG4gIGRlYnVnKGBTZXR0aW5nIFwiJHtjeGFwaS5ERUZBVUxUX1JFR0lPTl9FTlZ9XCIgZW52aXJvbm1lbnQgdmFyaWFibGUgdG9gLCBlbnZbY3hhcGkuREVGQVVMVF9SRUdJT05fRU5WXSk7XG5cbiAgY29uc3QgYWNjb3VudElkID0gKGF3YWl0IGF3cy5kZWZhdWx0QWNjb3VudCgpKT8uYWNjb3VudElkO1xuICBpZiAoYWNjb3VudElkKSB7XG4gICAgZW52W2N4YXBpLkRFRkFVTFRfQUNDT1VOVF9FTlZdID0gYWNjb3VudElkO1xuICAgIGRlYnVnKGBTZXR0aW5nIFwiJHtjeGFwaS5ERUZBVUxUX0FDQ09VTlRfRU5WfVwiIGVudmlyb25tZW50IHZhcmlhYmxlIHRvYCwgZW52W2N4YXBpLkRFRkFVTFRfQUNDT1VOVF9FTlZdKTtcbiAgfVxufVxuXG4vKipcbiAqIE1ha2Ugc3VyZSB0aGUgJ2FwcCcgaXMgYW4gYXJyYXlcbiAqXG4gKiBJZiBpdCdzIGEgc3RyaW5nLCBzcGxpdCBvbiBzcGFjZXMgYXMgYSB0cml2aWFsIHdheSBvZiB0b2tlbml6aW5nIHRoZSBjb21tYW5kIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIGFwcFRvQXJyYXkoYXBwOiBhbnkpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcHAgPT09ICdzdHJpbmcnID8gYXBwLnNwbGl0KCcgJykgOiBhcHA7XG59XG5cbnR5cGUgQ29tbWFuZEdlbmVyYXRvciA9IChmaWxlOiBzdHJpbmcpID0+IHN0cmluZ1tdO1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdpdmVuIGZpbGUgd2l0aCB0aGUgc2FtZSAnbm9kZScgcHJvY2VzcyBhcyBpcyBydW5uaW5nIHRoZSBjdXJyZW50IHByb2Nlc3NcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZU5vZGUoc2NyaXB0RmlsZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICByZXR1cm4gW3Byb2Nlc3MuZXhlY1BhdGgsIHNjcmlwdEZpbGVdO1xufVxuXG4vKipcbiAqIE1hcHBpbmcgb2YgZXh0ZW5zaW9ucyB0byBjb21tYW5kLWxpbmUgZ2VuZXJhdG9yc1xuICovXG5jb25zdCBFWFRFTlNJT05fTUFQID0gbmV3IE1hcDxzdHJpbmcsIENvbW1hbmRHZW5lcmF0b3I+KFtcbiAgWycuanMnLCBleGVjdXRlTm9kZV0sXG5dKTtcblxuLyoqXG4gKiBHdWVzcyB0aGUgZXhlY3V0YWJsZSBmcm9tIHRoZSBjb21tYW5kLWxpbmUgYXJndW1lbnRcbiAqXG4gKiBPbmx5IGRvIHRoaXMgaWYgdGhlIGZpbGUgaXMgTk9UIG1hcmtlZCBhcyBleGVjdXRhYmxlLiBJZiBpdCBpcyxcbiAqIHdlJ2xsIGRlZmVyIHRvIHRoZSBzaGViYW5nIGluc2lkZSB0aGUgZmlsZSBpdHNlbGYuXG4gKlxuICogSWYgd2UncmUgb24gV2luZG93cywgd2UgQUxXQVlTIHRha2UgdGhlIGhhbmRsZXIsIHNpbmNlIGl0J3MgaGFyZCB0b1xuICogdmVyaWZ5IGlmIHJlZ2lzdHJ5IGFzc29jaWF0aW9ucyBoYXZlIG9yIGhhdmUgbm90IGJlZW4gc2V0IHVwIGZvciB0aGlzXG4gKiBmaWxlIHR5cGUsIHNvIHdlJ2xsIGFzc3VtZSB0aGUgd29yc3QgYW5kIHRha2UgY29udHJvbC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ3Vlc3NFeGVjdXRhYmxlKGNvbW1hbmRMaW5lOiBzdHJpbmdbXSkge1xuICBpZiAoY29tbWFuZExpbmUubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgZnN0YXQgPSBhd2FpdCBmcy5zdGF0KGNvbW1hbmRMaW5lWzBdKTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxuICAgIGNvbnN0IGlzRXhlY3V0YWJsZSA9IChmc3RhdC5tb2RlICYgZnMuY29uc3RhbnRzLlhfT0spICE9PSAwO1xuICAgIGNvbnN0IGlzV2luZG93cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG5cbiAgICBjb25zdCBoYW5kbGVyID0gRVhURU5TSU9OX01BUC5nZXQocGF0aC5leHRuYW1lKGNvbW1hbmRMaW5lWzBdKSk7XG4gICAgaWYgKGhhbmRsZXIgJiYgKCFpc0V4ZWN1dGFibGUgfHwgaXNXaW5kb3dzKSkge1xuICAgICAgcmV0dXJuIGhhbmRsZXIoY29tbWFuZExpbmVbMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tbWFuZExpbmU7XG59XG4iXX0=